---
phase: 27-daily-limit
plan: 04
type: execute
wave: 3
depends_on: [27-01, 27-02, 27-03]
files_modified: [src/hooks/useUserLimits.ts, src/hooks/useCoach.ts]
autonomous: true
must_haves:
  truths:
    - "Client can fetch current usage counts (rec_count, chat_count) from user_limits table"
    - "Query uses staleTime: 0 for fresh data on every fetch"
    - "Hook returns rec_count, chat_count, and limit_date for display"
    - "useGenerateRecommendations and useStreamingChat invalidate limits query on success"
  artifacts:
    - path: "src/hooks/useUserLimits.ts"
      provides: "React hook for fetching daily usage limits"
      exports: ["useUserLimits", "getTimeUntilNextReset"]
    - path: "src/hooks/useCoach.ts"
      provides: "Updated hooks with limit invalidation"
      exports: ["useGenerateRecommendations", "useStreamingChat"]
  key_links:
    - from: "src/hooks/useUserLimits.ts"
      to: "public.user_limits"
      via: "Supabase query"
      pattern: "supabase\\.from\\('user_limits'\\)"
    - from: "src/hooks/useCoach.ts"
      to: "useUserLimits"
      via: "Import and invalidate on success"
      pattern: "queryClient\\.invalidateQueries\\(\\['user-limits'\\]\\)"
---

<objective>
Create client-side hook for fetching usage limits and update existing hooks to invalidate limits after actions.

Purpose: Display current usage counts inline in UI and refresh counts after each action (recommendation generation, chat message).
Output: useUserLimits hook with fresh data fetching and updated hooks that invalidate limits on mutations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/27-daily-limit/27-CONTEXT.md
@.planning/phases/27-daily-limit/27-RESEARCH.md
@.planning/phases/27-daily-limit/27-02-SUMMARY.md
@.planning/phases/27-daily-limit/27-03-SUMMARY.md

@src/hooks/useCoach.ts
</context>

<tasks>

<task type="auto">
  <name>Create useUserLimits hook for fetching daily usage limits</name>
  <files>src/hooks/useUserLimits.ts</files>
  <action>
Create new hook file src/hooks/useUserLimits.ts with:

1. Import statements:
   import { useQuery } from '@tanstack/react-query'
   import { supabase } from '@/lib/supabase'

2. Define query key export:
   export const userLimitsKeys = {
     all: ['user-limits'] as const,
     current: () => [...userLimitsKeys.all, 'current'] as const,
   }

3. Export useUserLimits hook:
   export function useUserLimits() {
     return useQuery({
       queryKey: userLimitsKeys.current(),
       queryFn: async () => {
         const { data: { user } } = await supabase.auth.getUser()

         if (!user) {
           return null
         }

         const { data, error } = await supabase
           .from('user_limits')
           .select('rec_count, chat_count, limit_date')
           .eq('user_id', user.id)
           .maybeSingle()

         if (error) {
           throw error
         }

         return data
       },
       staleTime: 0,      // Always fetch fresh data (required by CONTEXT.md)
       gcTime: 30 * 1000, // Cache for 30s (short duration)
     })
   }

4. Export getTimeUntilNextReset helper function:
   export function getTimeUntilNextReset(): string {
     const now = new Date()
     const tomorrow = new Date(now)
     tomorrow.setUTCDate(tomorrow.getUTCDate() + 1)
     tomorrow.setUTCHours(0, 0, 0, 0) // Set to UTC midnight

     const msUntilReset = tomorrow.getTime() - now.getTime()
     const hoursUntilReset = Math.ceil(msUntilReset / (1000 * 60 * 60))

     if (hoursUntilReset <= 1) {
       return 'Next reset in less than 1 hour'
     } else if (hoursUntilReset < 24) {
       return `Next reset in ${hoursUntilReset} hours`
     } else {
       return 'Next reset tomorrow at midnight UTC'
     }
   }

5. Export types for TypeSafety:
   export interface UserLimits {
     rec_count: number
     chat_count: number
     limit_date: string
   }

IMPORTANT: Use maybeSingle() instead of single() to handle users without limits row yet (returns null instead of error).
IMPORTANT: staleTime: 0 ensures we always fetch fresh data (required by CONTEXT.md).
</action>
  <verify>
1. Run: pnpm typecheck
2. Verify no TypeScript errors
3. Check imports are correct (supabase, @tanstack/react-query)
4. Verify queryKey follows TanStack Query naming convention
5. Verify staleTime is set to 0 as required
6. Verify getTimeUntilNextReset returns correct time for different scenarios (1 hour, 5 hours, 24 hours)
</verify>
  <done>
useUserLimits hook created with:
- Query for fetching rec_count, chat_count, limit_date from user_limits table
- staleTime: 0 for fresh data on every fetch
- getTimeUntilNextReset helper for calculating hours until UTC midnight reset
- Proper handling of users without limits row (returns null)
</done>
</task>

<task type="auto">
  <name>Update useGenerateRecommendations and useStreamingChat to invalidate limits</name>
  <files>src/hooks/useCoach.ts</files>
  <action>
Update existing hooks to invalidate user-limits query after successful mutations.

1. Add import for userLimitsKeys:
   import { userLimitsKeys } from './useUserLimits'

2. In useGenerateRecommendations hook (around line 84), add invalidation to onSuccess callback:
   export function useGenerateRecommendations() {
     const queryClient = useQueryClient()

     return useMutation({
       mutationFn: generateRecommendations,
       onSuccess: () => {
         // Invalidate recommendations cache to fetch fresh data after regeneration
         void queryClient.invalidateQueries({
           queryKey: coachKeys.currentRecommendations(),
         })
         // Invalidate user limits to refresh counter display
         void queryClient.invalidateQueries({
           queryKey: userLimitsKeys.current(),
         })
       },
       onError: (error) => {
         console.error('Failed to generate recommendations:', error)
         // Don't throw - UI will show cached recommendations
       },
     })
   }

3. In useStreamingChat hook (if it's in this file, or create separate import if it's elsewhere), find the onSuccess callback and add:
   void queryClient.invalidateQueries({
     queryKey: userLimitsKeys.current(),
   })

   Note: useStreamingChat might be in a separate file (src/hooks/useStreamingChat.ts). If so, update that file instead.

4. Verify no other changes needed to existing hooks.

IMPORTANT: Invalidating the query forces a refetch to get the updated counter from the database.
IMPORTANT: This ensures counter displays correct value after each action.
</action>
  <verify>
1. Run: pnpm typecheck
2. Verify import for userLimitsKeys is correct
3. Verify invalidation added to useGenerateRecommendations onSuccess callback
4. Verify invalidation added to useStreamingChat onSuccess callback (or in correct file)
5. Check that queryClient.invalidateQueries uses correct queryKey: userLimitsKeys.current()
</verify>
  <done>
useGenerateRecommendations and useStreamingChat hooks updated to:
- Invalidate user-limits query on successful mutations
- Refresh counter display after each action (recommendation generation, chat message)
- Maintain existing functionality (recommendations cache, error handling)
</done>
</task>

</tasks>

<verification>
1. useUserLimits hook file created with correct exports
2. Hook queries user_limits table with staleTime: 0
3. getTimeUntilNextReset returns correct time strings for different scenarios
4. useGenerateRecommendations invalidates user-limits on success
5. useStreamingChat invalidates user-limits on success
6. TypeScript type checking passes
7. No existing functionality broken by changes
</verification>

<success_criteria>
Client can fetch daily usage limits and refresh counts after actions. Hooks are ready for UI integration.
</success_criteria>

<output>
After completion, create `.planning/phases/27-daily-limit/27-04-SUMMARY.md`
</output>
