---
phase: 31-ai-tag-extraction-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260121000001_add_tag_count.sql
  - supabase/migrations/20260121000002_create_tag_extraction_api_usage.sql
  - supabase/migrations/20260121000003_add_tags_extracted_at.sql
autonomous: true

must_haves:
  truths:
    - user_limits table has tag_count column that increments on each extraction
    - increment_tag_count RPC function exists and can be called
    - tag_extraction_api_usage table tracks cost, tokens, and model usage
    - climbs table has tags_extracted_at timestamp for deduplication
  artifacts:
    - path: supabase/migrations/20260121000001_add_tag_count.sql
      provides: tag_count column and increment_tag_count RPC function
      contains: "ALTER TABLE public.user_limits ADD COLUMN tag_count"
    - path: supabase/migrations/20260121000002_create_tag_extraction_api_usage.sql
      provides: API usage tracking table
      contains: "CREATE TABLE public.tag_extraction_api_usage"
    - path: supabase/migrations/20260121000003_add_tags_extracted_at.sql
      provides: Extraction timestamp for deduplication
      contains: "ALTER TABLE public.climbs ADD COLUMN tags_extracted_at"
  key_links:
    - from: "increment_tag_count RPC function"
      to: "user_limits.tag_count"
      via: "atomic increment with date reset"
      pattern: "INSERT.*ON CONFLICT.*DO UPDATE SET tag_count"
---

<objective>
Database migrations for AI tag extraction - adds tracking infrastructure (tag_count column, RPC function, API usage table) to support quota enforcement and cost tracking.

Purpose: Provides the data foundation required by Edge Function for quota enforcement (EXTR-06) and cost tracking (EXTR-05).
Output: Three migration files executed on Supabase database.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/31-ai-tag-extraction-service/31-RESEARCH.md
@.planning/phases/31-ai-tag-extraction-service/31-CONTEXT.md
@.planning/REQUIREMENTS.md

# Existing migrations reference
@supabase/migrations/20260119140000_create_user_limits.sql
@supabase/migrations/20250117104148_create_profiles.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration to add tag_count column and RPC function</name>
  <files>supabase/migrations/20260121000001_add_tag_count.sql</files>
  <action>
    Create migration file supabase/migrations/20260121000001_add_tag_count.sql that:

    1. Adds tag_count column to user_limits table:
       - Type: INTEGER NOT NULL DEFAULT 0
       - CHECK constraint: tag_count >= 0

    2. Creates increment_tag_count RPC function:
       - Input: p_user_id UUID
       - Returns: VOID
       - Inserts row with tag_count=1 and limit_date=CURRENT_DATE if user doesn't exist
       - On conflict, atomically increments tag_count and updates limit_date
       - Implements date reset: if limit_date < CURRENT_DATE, reset to 1; otherwise, increment by 1

    3. Grants EXECUTE on increment_tag_count to authenticated role

    Follow the pattern from supabase/migrations/20260119140000_create_user_limits.sql (lines 29-43) for increment_tag_count.

    Use format: 20260121000001 (YYYYMMDDHHMMSS sequence).
  </action>
  <verify>
    Run: npx supabase db push
    Check: "SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'user_limits' AND column_name = 'tag_count';" returns one row with type "integer"
    Check: "SELECT proname FROM pg_proc WHERE proname = 'increment_tag_count';" returns one row
  </verify>
  <done>tag_count column exists in user_limits table and increment_tag_count RPC function is callable</done>
</task>

<task type="auto">
  <name>Task 2: Create migration for tag_extraction_api_usage table</name>
  <files>supabase/migrations/20260121000002_create_tag_extraction_api_usage.sql</files>
  <action>
    Create migration file supabase/migrations/20260121000002_create_tag_extraction_api_usage.sql that:

    1. Creates tag_extraction_api_usage table with columns:
       - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - user_id: UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE
       - prompt_tokens: INTEGER NOT NULL
       - completion_tokens: INTEGER NOT NULL
       - total_tokens: INTEGER NOT NULL
       - cost_usd: NUMERIC(10, 6) NOT NULL DEFAULT 0
       - model: TEXT NOT NULL
       - endpoint: TEXT NOT NULL DEFAULT 'openrouter-tag-extract'
       - time_window_start: TIMESTAMPTZ NOT NULL
       - created_at: TIMESTAMPTZ NOT NULL DEFAULT now()

    2. Enables RLS on the table

    3. Creates RLS policy for SELECT: "Users can view own tag extraction usage" (auth.uid() = user_id)

    4. Creates indexes:
       - tag_extraction_api_usage_user_id_idx on user_id
       - tag_extraction_api_usage_time_window_idx on time_window_start

    5. Note: No INSERT/UPDATE policies - Edge Functions use service role key

    Follow the pattern from the research document (lines 586-617) and existing coach_api_usage table structure.

    Use format: 20260121000002 (next in sequence).
  </action>
  <verify>
    Run: npx supabase db push
    Check: "SELECT table_name FROM information_schema.tables WHERE table_name = 'tag_extraction_api_usage';" returns one row
    Check: "SELECT indexname FROM pg_indexes WHERE tablename = 'tag_extraction_api_usage';" returns two rows (user_id and time_window)
  </verify>
  <done>tag_extraction_api_usage table exists with proper RLS policies and indexes</done>
</task>

<task type="auto">
  <name>Task 3: Add tags_extracted_at column to climbs table</name>
  <files>supabase/migrations/20260121000003_add_tags_extracted_at.sql</files>
  <action>
    Create migration file supabase/migrations/20260121000003_add_tags_extracted_at.sql that:

    1. Adds tags_extracted_at column to climbs table:
       - Type: TIMESTAMPTZ
       - Nullable: Yes (no default, initially null)

    2. Purpose: Track when tags were last extracted for a climb to prevent duplicate extractions

    Use format: 20260121000003 (next in sequence).
  </action>
  <verify>
    Run: npx supabase db push
    Check: "SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'climbs' AND column_name = 'tags_extracted_at';" returns one row with type "timestamp with time zone"
  </verify>
  <done>tags_extracted_at column exists in climbs table for deduplication</done>
</task>

</tasks>

<verification>
After completion:
1. Run "npx supabase types typescript" to verify no schema errors
2. Check "npx supabase migration list" shows all three migrations applied
3. Verify "SELECT * FROM user_limits LIMIT 1;" shows tag_count column
4. Verify "SELECT increment_tag_count('00000000-0000-0000-0000-000000000000'::uuid);" executes without error (should create row for test UUID)
5. Verify "SELECT * FROM tag_extraction_api_usage LIMIT 1;" returns empty result (table exists, no rows yet)
6. Verify "SELECT tags_extracted_at FROM climbs LIMIT 1;" shows nullable column
</verification>

<success_criteria>
All three migrations successfully applied to Supabase database. Database ready for Edge Function implementation in Plan 02.
</success_criteria>

<output>
After completion, create `.planning/phases/31-ai-tag-extraction-service/31-01-SUMMARY.md`
</output>
