---
phase: 21-chat-interface
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/hooks/useStreamingChat.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "npm install @microsoft/fetch-event-source completes without errors"
    - "useStreamingChat hook provides sendMessage, streamingResponse, isStreaming, error, cleanup functions"
    - "sendMessage function saves user message to database via useCreateCoachMessage"
    - "sendMessage function connects to /functions/v1/openrouter-chat via SSE"
    - "Streaming chunks update streamingResponse state in real-time"
    - "AbortController cleanup prevents memory leaks"
    - "Assistant message saved to database after streaming completes"
  artifacts:
    - path: "src/hooks/useStreamingChat.ts"
      provides: "React hook for SSE streaming chat"
      min_lines: 100
  key_links:
    - from: "src/hooks/useStreamingChat.ts"
      to: "/functions/v1/openrouter-chat"
      via: "@microsoft/fetch-event-source"
      pattern: "fetchEventSource\\('/functions/v1/openrouter-chat'"
    - from: "src/hooks/useStreamingChat.ts"
      to: "supabase.from('coach_messages').insert()"
      via: "useCreateCoachMessage hook"
      pattern: "createMessage\\.mutateAsync|createMessage\\.mutate"
---

<objective>
Create client-side SSE service with @microsoft/fetch-event-source and React hook for streaming chat.

Purpose: Handle SSE connection from client to Edge Function, manage streaming state, and save messages to database.
Output: React hook (src/hooks/useStreamingChat.ts) that manages SSE connection, streaming state, and message persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/hooks/useCoachMessages.ts
@src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @microsoft/fetch-event-source</name>
  <files>package.json</files>
  <action>
    Run: npm install @microsoft/fetch-event-source

    This library provides better SSE support than native EventSource (supports POST, custom headers, body, abort signals).
  </action>
  <verify>
    Check package.json includes "@microsoft/fetch-event-source" in dependencies
  </verify>
  <done>
    @microsoft/fetch-event-source installed and available in project
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useStreamingChat hook</name>
  <files>src/hooks/useStreamingChat.ts</files>
  <action>
    Create src/hooks/useStreamingChat.ts with:

    1. Imports:
       - useState, useRef, useCallback, useEffect from 'react'
       - fetchEventSource from '@microsoft/fetch-event-source'
       - useCreateCoachMessage from '@/hooks/useCoachMessages'
       - supabase from '@/lib/supabase'

    2. Export function useStreamingChat() returning:
       - sendMessage: (message: string, patterns: any) => Promise<void>
       - streamingResponse: string
       - isStreaming: boolean
       - error: string | null
       - cleanup: () => void

    3. State variables:
       - streamingResponse state (string, initialized to '')
       - isStreaming state (boolean, initialized to false)
       - error state (string | null, initialized to null)
       - abortControllerRef (ref for AbortController)

    4. sendMessage function:
       - Validate message not empty and not already streaming
       - Create new AbortController, store in ref
       - Set isStreaming: true, streamingResponse: '', error: null
       - Call createMessage.mutateAsync to save user message (role: 'user', content: message, context: { patterns_data: patterns })
       - Get session via supabase.auth.getSession()
       - Throw error if no session
       - Initialize fullResponse accumulator variable
       - Call fetchEventSource with:
         - method: 'POST'
         - url: '/functions/v1/openrouter-chat'
         - headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${session.access_token}` }
         - body: JSON.stringify({ message, patterns_data: patterns })
         - signal: abortController.signal
         - onmessage(ev): parse JSON, if data.content append to fullResponse, set streamingResponse, if data.error set error
         - onopen(response): validate response.ok and content-type === 'text/event-stream', throw error otherwise
         - onclose(): set isStreaming: false, if fullResponse and no error, save assistant message via createMessage.mutate()
         - onerror(err): set isStreaming: false, set error, return (don't throw to prevent retry)
       - Handle try/catch around fetchEventSource, set error state on failure

    5. Cleanup function:
       - Call abortControllerRef.current?.abort()
       - Set abortControllerRef.current to null

    6. Return interface with all exposed functions and state

    Reference useCoachMessages.ts for createMessage mutation pattern and supabase auth pattern.
  </action>
  <verify>
    Verify hook structure: check file exports useStreamingChat function with sendMessage, streamingResponse, isStreaming, error, cleanup return values. Verify import of @microsoft/fetch-event-source is present.
  </verify>
  <done>
    React hook manages SSE connection, streaming state, and message persistence with proper cleanup
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- @microsoft/fetch-event-source installed in package.json
- useStreamingChat hook exports all required functions and state
- sendMessage function creates user message in database before SSE call
- SSE connection established with proper headers and body
- Streaming chunks update streamingResponse state
- AbortController cleanup prevents memory leaks
- Assistant message saved after streaming completes
</verification>

<success_criteria>
Client-side SSE hook operational with message persistence and cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/21-chat-interface/21-02-SUMMARY.md`
</output>
