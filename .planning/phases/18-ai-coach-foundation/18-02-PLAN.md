---
phase: 18-ai-coach-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/patterns.ts
  - src/types/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "extractPatterns() function aggregates climb data into failure patterns, style weaknesses, frequency, and successes"
    - "Failure patterns identify top 5 most common failure reasons with counts and percentages"
    - "Style weaknesses identify top 5 struggling styles with fail rates (min 3 attempts)"
    - "Climbing frequency tracks climbs per week, monthly average, and average per session"
    - "Recent successes show last 10 sends, grade progression, and redemption count"
    - "Service handles empty climb data by returning empty patterns (no crashes)"
  artifacts:
    - path: "src/services/patterns.ts"
      provides: "Pattern extraction from climb logs"
      exports:
        - "extractPatterns"
        - "FailurePatterns"
        - "StyleWeaknesses"
        - "ClimbingFrequency"
        - "RecentSuccesses"
        - "PatternAnalysis"
    - path: "src/types/index.ts"
      provides: "Pattern analysis interfaces"
      contains: ["PatternAnalysis", "FailurePatterns", "StyleWeaknesses", "ClimbingFrequency", "RecentSuccesses"]
  key_links:
    - from: "src/services/patterns.ts"
      to: "src/services/climbs.ts"
      via: "Uses getClimbs() to fetch user's climb data"
      pattern: "from '@/services/climbs'"
    - from: "src/services/patterns.ts"
      to: "src/lib/grades.ts"
      via: "Uses normalizeGrade() for grade progression calculation"
      pattern: "from '@/lib/grades'"
---

<objective>
Create patterns service that extracts climbing insights from logged climbs

Purpose: Transform raw climb data into actionable patterns (failures, weaknesses, frequency, successes) for AI context
Output: patterns.ts service with extractPatterns() function returning PatternAnalysis object
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-ai-coach-foundation/18-RESEARCH.md
@src/services/climbs.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pattern analysis types to types/index.ts</name>
  <files>src/types/index.ts</files>
  <action>
Add pattern analysis interfaces to src/types/index.ts:

```typescript
// Pattern Analysis Types (for AI Coach)
export interface FailurePatterns {
  most_common_failure_reasons: Array<{
    reason: string
    count: number
    percentage: number
  }>
}

export interface StyleWeaknesses {
  struggling_styles: Array<{
    style: string
    fail_count: number
    total_attempts: number
    fail_rate: number
  }>
}

export interface ClimbingFrequency {
  climbs_per_week: Array<{
    week: string
    count: number
  }>
  climbs_per_month: number
  avg_climbs_per_session: number
}

export interface RecentSuccesses {
  recent_sends: Climb[]
  grade_progression: Array<{
    grade: string
    date: string
  }>
  redemption_count: number
}

export interface PatternAnalysis {
  failure_patterns: FailurePatterns
  style_weaknesses: StyleWeaknesses
  climbing_frequency: ClimbingFrequency
  recent_successes: RecentSuccesses
}
```

Add after existing HoldColor type, before Climb interface.

Why: These interfaces define the shape of pattern data extracted from climbs for AI analysis.
  </action>
  <verify>Run `pnpm typecheck` - no TypeScript errors. Verify types defined: `grep -c "PatternAnalysis\|FailurePatterns\|StyleWeaknesses" src/types/index.ts` shows all types present.</verify>
  <done>Pattern analysis types defined in types/index.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create patterns service with extraction logic</name>
  <files>src/services/patterns.ts</files>
  <action>
Create src/services/patterns.ts with the following:

```typescript
import { supabase } from '@/lib/supabase'
import { normalizeGrade } from '@/lib/grades'
import type { Climb, PatternAnalysis } from '@/types'

export async function extractPatterns(userId: string): Promise<PatternAnalysis> {
  const { data: climbs, error } = await supabase
    .from('climbs')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })
    .limit(100) // Last 100 climbs for analysis

  if (error) {
    throw error
  }

  if (!climbs || climbs.length === 0) {
    return getEmptyPatterns()
  }

  return {
    failure_patterns: extractFailurePatterns(climbs),
    style_weaknesses: extractStyleWeaknesses(climbs),
    climbing_frequency: extractClimbingFrequency(climbs),
    recent_successes: extractRecentSuccesses(climbs),
  }
}

function extractFailurePatterns(climbs: Climb[]) {
  const failedClimbs = climbs.filter((c) => c.outcome === 'Fail')
  const reasonCounts = new Map<string, number>()

  failedClimbs.forEach((climb) => {
    climb.failure_reasons.forEach((reason) => {
      reasonCounts.set(reason, (reasonCounts.get(reason) || 0) + 1)
    })
  })

  const sorted = Array.from(reasonCounts.entries())
    .sort(([, a], [, b]) => b - a)
    .slice(0, 5) // Top 5

  return {
    most_common_failure_reasons: sorted.map(([reason, count]) => ({
      reason,
      count,
      percentage: Math.round((count / failedClimbs.length) * 100),
    })),
  }
}

function extractStyleWeaknesses(climbs: Climb[]) {
  const styleStats = new Map<string, { fail_count: number; total_attempts: number }>()

  climbs.forEach((climb) => {
    climb.style.forEach((s) => {
      const current = styleStats.get(s) || { fail_count: 0, total_attempts: 0 }
      current.total_attempts++
      if (climb.outcome === 'Fail') {
        current.fail_count++
      }
      styleStats.set(s, current)
    })
  })

  const sorted = Array.from(styleStats.entries())
    .map(([style, stats]) => ({
      style,
      fail_rate: stats.total_attempts > 0 ? stats.fail_count / stats.total_attempts : 0,
      ...stats,
    }))
    .filter((s) => s.total_attempts >= 3) // Only analyze styles with 3+ attempts
    .sort((a, b) => b.fail_rate - a.fail_rate)
    .slice(0, 5) // Top 5 weaknesses

  return { struggling_styles: sorted }
}

function extractClimbingFrequency(climbs: Climb[]) {
  const weekCounts = new Map<string, number>()

  climbs.forEach((climb) => {
    const date = new Date(climb.created_at)
    const weekKey = getWeekKey(date)
    weekCounts.set(weekKey, (weekCounts.get(weekKey) || 0) + 1)
  })

  const sortedWeeks = Array.from(weekCounts.entries())
    .sort(([a], [b]) => b.localeCompare(a))
    .slice(0, 12) // Last 12 weeks

  const climbsPerWeek = sortedWeeks.map(([week, count]) => ({
    week: formatWeek(week),
    count,
  }))

  const totalClimbs = climbs.length
  const daysSpanned = getDaysSpanned(climbs[0].created_at, climbs[climbs.length - 1].created_at)
  const avgPerMonth = daysSpanned > 0 ? Math.round((totalClimbs / daysSpanned) * 30) : 0

  return {
    climbs_per_week: climbsPerWeek,
    climbs_per_month: avgPerMonth,
    avg_climbs_per_session: calculateAvgPerSession(climbs),
  }
}

function extractRecentSuccesses(climbs: Climb[]) {
  const recentSends = climbs.filter((c) => c.outcome === 'Sent').slice(0, 10)

  // Track highest grade sent
  const maxGradeSent = recentSends.reduce((max, climb) => {
    const normalized = normalizeGrade(climb.grade_scale, climb.grade_value)
    return normalized > max ? normalized : max
  }, 0)

  const gradeProgression = recentSends
    .filter((c) => {
      const normalized = normalizeGrade(c.grade_scale, c.grade_value)
      return normalized === maxGradeSent
    })
    .slice(0, 5)
    .map((climb) => ({
      grade: `${climb.grade_scale}:${climb.grade_value}`,
      date: new Date(climb.created_at).toLocaleDateString(),
    }))

  const redemptions = climbs.filter((c) => c.redemption_at !== null).length

  return {
    recent_sends: recentSends,
    grade_progression: gradeProgression,
    redemption_count: redemptions,
  }
}

function getEmptyPatterns(): PatternAnalysis {
  return {
    failure_patterns: { most_common_failure_reasons: [] },
    style_weaknesses: struggling_styles: [] },
    climbing_frequency: {
      climbs_per_week: [],
      climbs_per_month: 0,
      avg_climbs_per_session: 0,
    },
    recent_successes: {
      recent_sends: [],
      grade_progression: [],
      redemption_count: 0,
    },
  }
}

function getWeekKey(date: Date): string {
  const year = date.getFullYear()
  const week = getWeekNumber(date)
  return `${year}-W${week}`
}

function getWeekNumber(date: Date): number {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()))
  const dayNum = d.getUTCDay() || 7
  d.setUTCDate(d.getUTCDate() + 4 - dayNum)
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1))
  return Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7)
}

function formatWeek(weekKey: string): string {
  const [year, week] = weekKey.split('-W')
  return `Week ${week}, ${year}`
}

function getDaysSpanned(start: string, end: string): number {
  const startDate = new Date(start)
  const endDate = new Date(end)
  return Math.ceil((startDate.getTime() - endDate.getTime()) / (1000 * 60 * 60 * 24))
}

function calculateAvgPerSession(climbs: Climb[]): number {
  if (climbs.length === 0) return 0

  // Group climbs by day (approximate session)
  const sessions = new Map<string, number>()

  climbs.forEach((climb) => {
    const day = new Date(climb.created_at).toDateString()
    sessions.set(day, (sessions.get(day) || 0) + 1)
  })

  const totalSessions = sessions.size
  return Math.round(climbs.length / totalSessions)
}
```

This implementation:
- Uses existing climbs table and Climb type
- Handles empty data gracefully (no crashes)
- Returns top 5 items for each pattern
- Filters styles with < 3 attempts to avoid noise
- Uses ISO week format (YYYY-Wnn)
- Follows existing service patterns (climbs.ts structure)

Why: This service transforms raw climb data into structured insights that feed into AI recommendations.
  </action>
  <verify>Run `pnpm typecheck` - no errors. Verify exports: `grep -E "^export" src/services/patterns.ts` shows at least extractPatterns and all interfaces exported. Test with empty climbs data: write simple test file importing and calling extractPatterns with empty array - returns empty patterns without error.</verify>
  <done>patterns.ts service created with extractPatterns() returning PatternAnalysis</done>
</task>

</tasks>

<verification>
- TypeScript compiles without errors
- Patterns service exports all required functions and interfaces
- Empty climb data returns empty patterns (no crashes)
- Each extraction function handles edge cases (no data, single climb)
- Week number calculation is correct (ISO 8601 standard)
</verification>

<success_criteria>
Pattern extraction service complete:
- Aggregates climbs into failure patterns, style weaknesses, frequency, and successes
- Handles empty data gracefully
- Returns top 5 insights per category
- Ready for AI context injection
</success_criteria>

<output>
After completion, create `.planning/phases/18-ai-coach-foundation/18-02-SUMMARY.md`
</output>
