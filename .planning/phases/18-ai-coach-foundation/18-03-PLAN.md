---
phase: 18-ai-coach-foundation
plan: 03
type: execute
wave: 2
depends_on: [18-01, 18-02]
files_modified:
  - src/services/coach.ts
autonomous: true
user_setup:
  - service: openrouter
    why: "LLM API for generating recommendations"
    env_vars:
      - name: OPENROUTER_API_KEY
        source: "OpenRouter Dashboard -> API Keys"

must_haves:
  truths:
    - "getLatestRecommendations() fetches user's most recent recommendation by generation_date"
    - "checkUserRateLimit() validates user hasn't exceeded 50k tokens in last 24 hours"
    - "generateRecommendations() calls Edge Function with anonymized climb data"
    - "trackApiUsage() logs every API call with tokens, cost, model, endpoint"
    - "Rate limit throws error when exceeded with remaining tokens count"
    - "Failed API calls still tracked with cost=0 for monitoring"
  artifacts:
    - path: "src/services/coach.ts"
      provides: "LLM API abstraction with cost tracking and rate limiting"
      exports:
        - "coachKeys"
        - "getLatestRecommendations"
        - "checkUserRateLimit"
        - "generateRecommendations"
        - "trackApiUsage"
  key_links:
    - from: "src/services/coach.ts"
      to: "supabase/functions/generate-recommendations/index.ts"
      via: "Calls Edge Function via supabase.functions.invoke()"
      pattern: "await supabase.functions.invoke('generate-recommendations')"
    - from: "src/services/coach.ts"
      to: "src/services/patterns.ts"
      via: "Uses extractPatterns() to get climbing context"
      pattern: "import { extractPatterns } from '@/services/patterns'"
    - from: "src/services/coach.ts"
      to: "src/lib/coachUtils.ts"
      via: "Anonymizes data before Edge Function call"
      pattern: "import { anonymizeClimbsForAI } from '@/lib/coachUtils'"
---

<objective>
Create coach service with LLM API abstraction, cost tracking, and rate limiting

Purpose: Provide secure, rate-limited access to AI recommendations with usage monitoring
Output: coach.ts service with recommendation fetching, rate limiting, and cost tracking
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-ai-coach-foundation/18-RESEARCH.md
@src/services/climbs.ts
@src/services/patterns.ts
@src/types/index.ts
@supabase/migrations/20260117_create_coach_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create coach service with API abstraction</name>
  <files>src/services/coach.ts</files>
  <action>
Create src/services/coach.ts with the following:

```typescript
import { supabase } from '@/lib/supabase'
import { anonymizeClimbsForAI } from '@/lib/coachUtils'
import { extractPatterns } from '@/services/patterns'
import type { Climb } from '@/types'

export interface ApiUsage {
  id: string
  user_id: string
  prompt_tokens: number
  completion_tokens: number
  total_tokens: number
  cost_usd: number
  model: string
  endpoint: string
  time_window_start: string
}

export interface GenerateRecommendationsInput {
  climbs: Climb[]
  user_preferences: {
    preferred_discipline: string
    preferred_grade_scale: string
  }
}

export interface GenerateRecommendationsResponse {
  weekly_focus: string
  drills: Array<{
    name: string
    description: string
    sets: number
    reps: string
    rest: string
  }>
}

export const coachKeys = {
  all: ['coach'] as const,
  recommendations: () => [...coachKeys.all, 'recommendations'] as const,
  currentRecommendations: () => [...coachKeys.recommendations(), 'current'] as const,
}

export async function getLatestRecommendations(userId: string) {
  if (!supabase) {
    throw new Error('Supabase client not configured')
  }

  const { data, error } = await supabase
    .from('coach_recommendations')
    .select('*')
    .eq('user_id', userId)
    .order('generation_date', { ascending: false })
    .limit(1)
    .single()

  if (error) {
    if (error.code === 'PGRST116') {
      return null // No recommendations yet
    }
    throw error
  }

  return data
}

export async function checkUserRateLimit(userId: string): Promise<{
  allowed: boolean
  remaining: number
  resetAt?: string
}> {
  if (!supabase) {
    throw new Error('Supabase client not configured')
  }

  // Count API calls in last 24 hours
  const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()

  const { data: usage, error } = await supabase
    .from('coach_api_usage')
    .select('total_tokens')
    .eq('user_id', userId)
    .gte('created_at', dayAgo)

  if (error) {
    throw error
  }

  const tokensUsed = usage?.reduce((sum, u) => sum + u.total_tokens, 0) || 0
  const dailyLimit = 50000 // 50k tokens per day
  const remaining = Math.max(0, dailyLimit - tokensUsed)

  return {
    allowed: tokensUsed < dailyLimit,
    remaining,
  }
}

export async function generateRecommendations(
  input: GenerateRecommendationsInput,
): Promise<GenerateRecommendationsResponse> {
  if (!supabase) {
    throw new Error('Supabase client not configured')
  }

  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user) {
    throw new Error('Not authenticated')
  }

  // Check rate limit
  const rateLimit = await checkUserRateLimit(user.id)
  if (!rateLimit.allowed) {
    throw new Error(`Rate limit exceeded. ${rateLimit.remaining} tokens remaining.`)
  }

  // Anonymize data before API call
  const anonymizedClimbs = anonymizeClimbsForAI(input.climbs)
  const patterns = await extractPatterns(user.id)

  // Call Supabase Edge Function (stub for now - will implement in Phase 20)
  const { data, error } = await supabase.functions.invoke('generate-recommendations', {
    body: {
      user_id: user.id,
      climbs_data: anonymizedClimbs,
      patterns_data: patterns,
      user_preferences: input.user_preferences,
    },
  })

  if (error) {
    // Track failed attempt
    await trackApiUsage(user.id, {
      prompt_tokens: 0,
      completion_tokens: 0,
      total_tokens: 0,
      cost_usd: 0,
      model: 'openai/gpt-4o-mini',
      endpoint: 'generate-recommendations',
    }, true)

    throw new Error(`Failed to generate recommendations: ${error.message}`)
  }

  return data as GenerateRecommendationsResponse
}

export async function trackApiUsage(
  userId: string,
  usage: {
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    cost_usd: number
    model: string
    endpoint: string
  },
  isError: boolean = false,
): Promise<void> {
  if (!supabase) {
    throw new Error('Supabase client not configured')
  }

  const { error } = await supabase.from('coach_api_usage').insert({
    user_id: userId,
    prompt_tokens: usage.prompt_tokens,
    completion_tokens: usage.completion_tokens,
    total_tokens: usage.total_tokens,
    cost_usd: isError ? 0 : usage.cost_usd,
    model: usage.model,
    endpoint: usage.endpoint,
    time_window_start: new Date().toISOString(),
  })

  if (error) {
    console.error('Failed to track API usage:', error)
    // Don't throw - tracking failure shouldn't break the main flow
  }
}

function calculateCost(usage: {
  prompt_tokens: number
  completion_tokens: number
}): number {
  // OpenRouter pricing for gpt-4o-mini
  const promptCost = usage.prompt_tokens * 0.00015 / 1000 // $0.15 per 1M tokens
  const completionCost = usage.completion_tokens * 0.0006 / 1000 // $0.60 per 1M tokens
  return promptCost + completionCost
}
```

Key points:
- Follows existing climbs.ts service pattern with query keys
- Uses coach_api_usage table for rate limiting and cost tracking
- Calls Edge Function 'generate-recommendations' (stub until Phase 20)
- Anonymizes data before Edge Function call via coachUtils
- Tracks both successful and failed API calls
- calculateCost() helper function for cost tracking
- Rate limit: 50k tokens per 24 hours

Why: This provides a clean abstraction for AI recommendations with built-in cost monitoring and rate limiting, preventing runaway API costs.
  </action>
  <verify>Run `pnpm typecheck` - no errors. Verify exports: `grep -E "^export" src/services/coach.ts` shows all functions exported. Check coachKeys structure follows pattern: `grep -A 5 "coachKeys =" src/services/coach.ts` shows proper nested keys structure.</verify>
  <done>coach.ts service with API abstraction, rate limiting, and cost tracking</done>
</task>

</tasks>

<verification>
- TypeScript compiles without errors
- Service exports all required functions and types
- Rate limit check queries last 24 hours correctly
- Failed API calls still tracked (cost=0)
- Edge Function call includes anonymized data and patterns
- Cost calculation uses OpenRouter pricing for gpt-4o-mini
</verification>

<success_criteria>
Coach service complete:
- Fetches latest recommendations for user
- Validates rate limits before API calls
- Generates recommendations via Edge Function
- Tracks all API usage for cost monitoring
- Ready for Phase 20 LLM integration
</success_criteria>

<output>
After completion, create `.planning/phases/18-ai-coach-foundation/18-03-SUMMARY.md`
</output>
