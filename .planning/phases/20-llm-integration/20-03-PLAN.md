---
phase: 20-llm-integration
plan: 03
type: execute
wave: 2
depends_on: [20-01]
files_modified: [supabase/functions/openrouter-coach/index.ts, src/services/coach.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Edge Function fetches cached recommendations before generating new ones"
    - "API failures return cached recommendations with error message warning"
    - "Client coach.ts calls 'openrouter-coach' instead of 'generate-recommendations'"
    - "Users see helpful error messages when API fails but still have recommendations"
    - "Privacy safeguards validate anonymized data before LLM call"
  artifacts:
    - path: "supabase/functions/openrouter-coach/index.ts"
      provides: "Error handling with fallback to cached recommendations"
      contains: "getExistingRecommendations|fallback to cached"
    - path: "src/services/coach.ts"
      provides: "Updated Edge Function invocation"
      exports: ["generateRecommendations"]
  key_links:
    - from: "openrouter-coach/index.ts"
      to: "coach_recommendations"
      via: "Query existing recommendations before API call"
      pattern: "supabase\.from\('coach_recommendations'\)\.select\(\)\.eq"
    - from: "supabase.functions.invoke()"
      to: "openrouter-coach"
      via: "Edge Function call from client"
      pattern: "supabase\.functions\.invoke\('openrouter-coach'"
    - from: "validateAnonymizedData()"
      to: "patterns_data"
      via: "Defensive PII check before LLM call"
      pattern: "validateAnonymizedData\(patterns_data\)"
---

<objective>
Implement error handling with fallback to cached recommendations in the Edge Function and update the client-side coach.ts to call the correct function name.

Purpose: Provide graceful degradation when OpenRouter API fails by returning previously cached recommendations while informing the user of the issue, and fix the client-side function call to match the Edge Function name.

Output: Edge Function with fallback logic and client service calling 'openrouter-coach' function.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/20-llm-integration/20-CONTEXT.md
@.planning/phases/20-llm-integration/20-RESEARCH.md

# Prior Plans
@.planning/phases/20-llm-integration/20-01-PLAN.md
@.planning/phases/20-llm-integration/20-02-PLAN.md

# Existing Foundation
@workspace/src/services/coach.ts
@workspace/src/lib/coachUtils.ts
@workspace/supabase/migrations/20260117_create_coach_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error handling with fallback to cached recommendations in Edge Function</name>
  <files>supabase/functions/openrouter-coach/index.ts</files>
  <action>
    Implement fallback to cached recommendations:

    1. Create helper function to fetch existing recommendations:
       ```typescript
       async function getExistingRecommendations(userId: string): Promise<any | null> {
         const { data, error } = await supabase
           .from('coach_recommendations')
           .select('*')
           .eq('user_id', userId)
           .order('generation_date', { ascending: false })
           .limit(1)
           .single()

         if (error) {
           console.error('Failed to fetch existing recommendations:', error)
           return null
         }

         // Only return if there's valid content (not empty or error)
         if (data && data.content && Object.keys(data.content).length > 0 && !data.error_message) {
           return data
         }

         return null
       }
       ```

    2. Before calling OpenRouter API, fetch existing recommendations:
       ```typescript
       // Get cached recommendations for fallback
       const cachedRecommendations = await getExistingRecommendations(userId)
       ```

    3. Wrap the entire OpenRouter API call in try/catch with fallback:
       ```typescript
       try {
         // ... OpenRouter API call with retry logic ...

         return Response.json({
           success: true,
           content: validated,
           usage: { /* ... */ },
           is_cached: false
         })

       } catch (apiError) {
         console.error('OpenRouter API failed:', apiError.message)

         // Try to return cached recommendations
         if (cachedRecommendations) {
           // Update cached recommendations with new error message
           await supabase
             .from('coach_recommendations')
             .update({
               error_message: `Failed to generate new recommendations: ${apiError.message}`
             })
             .eq('id', cachedRecommendations.id)

           return Response.json({
             success: true,
             content: cachedRecommendations.content,
             is_cached: true,
             warning: `Unable to generate new recommendations. Showing previous recommendations from ${new Date(cachedRecommendations.generation_date).toLocaleDateString()}.`
           })
         }

         // No cached recommendations available - return error
         return Response.json({
           success: false,
           error: `Failed to generate recommendations and no cached data available: ${apiError.message}`
         }, { status: 500 })
       }
       ```

    4. Add defensive privacy check before LLM call (validateAnonymizedData):
       ```typescript
       import { validateAnonymizedData } from '@/lib/coachUtils'

       // Before calling OpenRouter API
       const piiFields = validateAnonymizedData(patterns_data)
       if (piiFields.length > 0) {
         console.error('PII detected in anonymized data:', piiFields)
         return Response.json({
           success: false,
           error: 'Privacy validation failed. Please try again.'
         }, { status: 400 })
       }
       ```

    5. Log all API failures with context (user_id, attempt number, error type)

    6. Ensure fallback only returns cached recommendations with valid content (not empty or with error_message)
  </action>
  <verify>
    Check that:
    - getExistingRecommendations() function queries coach_recommendations by user_id, desc order, limit 1
    - getExistingRecommendations() returns null if content is empty or has error_message
    - Cached recommendations are fetched before API call
    - API errors trigger fallback to cached recommendations
    - Fallback response includes is_cached: true and warning message
    - Fallback response includes cached content and generation_date
    - validateAnonymizedData() is called before LLM API call
    - Privacy validation returns 400 error if PII detected
    - API failures are logged with context
  </verify>
  <done>
    Error handling with fallback implemented with:
    - Helper function to fetch existing recommendations
    - Cached recommendations fetched before API call
    - API errors return cached data with warning message
    - No cached data available returns 500 error
    - Privacy validation before LLM call (validateAnonymizedData)
    - Logging for all API failures with context
  </done>
</task>

<task type="auto">
  <name>Task 2: Update coach.ts to call 'openrouter-coach' Edge Function</name>
  <files>src/services/coach.ts</files>
  <action>
    Fix the Edge Function invocation:

    1. In generateRecommendations() function, change the Edge Function call from 'generate-recommendations' to 'openrouter-coach':
       ```typescript
       // Old (incorrect):
       const { data, error } = await supabase.functions.invoke('generate-recommendations', {
       // New (correct):
       const { data, error } = await supabase.functions.invoke('openrouter-coach', {
       ```

    2. Update error handling to handle new response format:
       ```typescript
       if (error) {
         // Track failed attempt
         await trackApiUsage(
           user.id,
           {
             prompt_tokens: 0,
             completion_tokens: 0,
             total_tokens: 0,
             model: 'openai/gpt-4o-mini',
             endpoint: 'openrouter-coach',
           },
           true,
         )

         throw new Error(`Failed to generate recommendations: ${error.message}`)
       }

       // Handle Edge Function response format
       if (!data.success && data.error) {
         throw new Error(data.error)
       }

       // Return the content (Edge Function returns { success, content, usage, is_cached, warning })
       if (data.warning) {
         console.warn('Recommendations warning:', data.warning)
       }

       return {
         weekly_focus: data.content.weekly_focus,
         drills: data.content.drills
       } as GenerateRecommendationsResponse
       ```

    3. Update endpoint name in trackApiUsage calls to 'openrouter-coach'
       - Find all instances where endpoint: 'generate-recommendations'
       - Change to endpoint: 'openrouter-coach'

    4. Ensure TypeScript types are compatible with new response format

    5. Update error messages to be more helpful for users (include warning if cached data)
  </action>
  <verify>
    Check that:
    - supabase.functions.invoke() calls 'openrouter-coach' (not 'generate-recommendations')
    - Response handles data.success and data.error fields
    - Response extracts weekly_focus and drills from data.content
    - Warning messages from Edge Function are logged
    - trackApiUsage uses endpoint: 'openrouter-coach'
    - Error messages are helpful for users
  </verify>
  <done>
    Client-side coach.ts updated with:
    - Correct Edge Function name: 'openrouter-coach'
    - Response handling for new format (success, content, usage, is_cached, warning)
    - Updated endpoint name in trackApiUsage calls
    - Helpful error messages including cache warnings
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `pnpm typecheck` (client) and `deno check supabase/functions/openrouter-coach/index.ts` (Edge Function)
2. Client function calls correct Edge Function name: grep "generate-recommendations" src/services/coach.ts should return nothing
3. Fallback logic verified: Simulate API failure and confirm cached data is returned
4. Privacy validation verified: Test validateAnonymizedData() with sample data
</verification>

<success_criteria>
1. Edge Function fetches cached recommendations before calling OpenRouter API
2. API failures return cached recommendations with warning message
3. No cached data returns helpful error message
4. Privacy validation checks for PII before LLM call
5. Client coach.ts calls 'openrouter-coach' function
6. Response handling accounts for new Edge Function format
</success_criteria>

<output>
After completion, create `.planning/phases/20-llm-integration/20-03-SUMMARY.md`
</output>
